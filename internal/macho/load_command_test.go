// Copyright 2025 The zb Authors
// SPDX-License-Identifier: MIT

package macho

import (
	"encoding/binary"
	"testing"

	"github.com/google/go-cmp/cmp"
)

func TestSegmentCommandUnmarshal(t *testing.T) {
	tests := []struct {
		name string
		data []byte
		want SegmentCommand
	}{
		{
			name: "PageZero",
			data: []byte{
				0x19, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00,
				'_', '_', 'P', 'A', 'G', 'E', 'Z', 'E',
				'R', 'O', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
			want: SegmentCommand{
				Command:              LoadCmdSegment64,
				RawName:              [16]byte{'_', '_', 'P', 'A', 'G', 'E', 'Z', 'E', 'R', 'O'},
				VirtualMemoryAddress: 0x0000000000000000,
				VirtualMemorySize:    0x0000000100000000,
				FileOffset:           0,
				FileSize:             0,
				MaxProtection:        0x0,
				InitProtection:       0x0,
				Flags:                0x0,
			},
		},
		{
			name: "Text",
			data: []byte{
				0x19, 0x00, 0x00, 0x00, 0xe8, 0x00, 0x00, 0x00,
				'_', '_', 'T', 'E', 'X', 'T', 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
				0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
				0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				'_', '_', 't', 'e', 'x', 't', 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				'_', '_', 'T', 'E', 'X', 'T', 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x94, 0x3f, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
				0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x94, 0x3f, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x04, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				'_', '_', 'u', 'n', 'w', 'i', 'n', 'd',
				'_', 'i', 'n', 'f', 'o', 0x00, 0x00, 0x00,
				'_', '_', 'T', 'E', 'X', 'T', 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0xa8, 0x3f, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
				0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0xa8, 0x3f, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
			want: SegmentCommand{
				Command:              LoadCmdSegment64,
				RawName:              [16]byte{'_', '_', 'T', 'E', 'X', 'T'},
				VirtualMemoryAddress: 0x0000000100000000,
				VirtualMemorySize:    0x0000000000004000,
				FileOffset:           0,
				FileSize:             16384,
				MaxProtection:        0x00000005,
				InitProtection:       0x00000005,
				Flags:                0x0,
				Sections: []Section{
					{
						RawName:          [16]byte{'_', '_', 't', 'e', 'x', 't'},
						RawSegmentName:   [16]byte{'_', '_', 'T', 'E', 'X', 'T'},
						Address:          0x0000000100003f94,
						Size:             0x0000000000000014,
						Offset:           16276,
						Alignment:        2,
						RelocationOffset: 0,
						RelocationCount:  0,
						Flags:            0x80000400,
					},
					{
						RawName:          [16]byte{'_', '_', 'u', 'n', 'w', 'i', 'n', 'd', '_', 'i', 'n', 'f', 'o'},
						RawSegmentName:   [16]byte{'_', '_', 'T', 'E', 'X', 'T'},
						Address:          0x0000000100003fa8,
						Size:             0x0000000000000058,
						Offset:           16296,
						Alignment:        2,
						RelocationOffset: 0,
						RelocationCount:  0,
						Flags:            0x0,
					},
				},
			},
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			got := new(SegmentCommand)
			if err := got.UnmarshalMachO(binary.LittleEndian, test.data); err != nil {
				t.Fatal("UnmarshalMachO:", err)
			}
			if diff := cmp.Diff(&test.want, got); diff != "" {
				t.Errorf("-want +got:\n%s", diff)
			}
		})
	}
}

func TestLinkeditDataCommandUnmarshal(t *testing.T) {
	tests := []struct {
		name string
		data []byte
		want LinkeditDataCommand
	}{
		{
			name: "FunctionStarts",
			data: []byte{
				0x26, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
				0x30, 0x40, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
			},
			want: LinkeditDataCommand{
				Command:    LoadCmdFunctionStarts,
				DataOffset: 16432,
				DataSize:   8,
			},
		},
		{
			name: "DataInCode",
			data: []byte{
				0x29, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
				0x38, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
			want: LinkeditDataCommand{
				Command:    LoadCmdDataInCode,
				DataOffset: 16440,
				DataSize:   0,
			},
		},
		{
			name: "CodeSignature",
			data: []byte{
				0x1d, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
				0xa0, 0x40, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00,
			},
			want: LinkeditDataCommand{
				Command:    LoadCmdCodeSignature,
				DataOffset: 16544,
				DataSize:   280,
			},
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			got := new(LinkeditDataCommand)
			if err := got.UnmarshalMachO(binary.LittleEndian, test.data); err != nil {
				t.Fatal("UnmarshalMachO:", err)
			}
			if diff := cmp.Diff(&test.want, got); diff != "" {
				t.Errorf("-want +got:\n%s", diff)
			}
		})
	}
}
